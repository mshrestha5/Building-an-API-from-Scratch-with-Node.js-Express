# Building-an-API-from-Scratch-with-Node.js-Express

API from scratch. 
The most popular framework for building restful API's and node is express Js. It's been around forever, and it's very minimal and easy to learn if you know a little bit of JavaScript. Over the next few minutes, we'll use Express to build our own RESTful API from scratch. You'll learn how to create different endpoints for your API. We'll also look at slightly more advanced concepts like middleware and tools in the cloud for deploying your API like API gateways. 

To get started, you'll want to open up VS code to an empty directory. 
You'll need to have node JS installed and I'm using version 12 
For this video, to start a new node project, let's run NPM init- y.  from the command line. And this will create a package json and give us a context for installing packages that we can use in Node like Express. 
Let's go ahead and install Express using npm install. You'll notice that adds express to our dependencies in the package json file. 

From there, we'll need a file to write our code in. So let's create an index.js file. At the top of that file will declare a variable for app which represents the actual API that we're building. And its value is an import of the Express package, which itself is a function so we'll add parentheses after it to initialize it. 

Now, at this point, our API hasn't defined any endpoint. But let's go ahead and run it anyway.

 The way you fire up your API on the server is by calling app dot Listen, that tells it to listen on a specific port which we've defined as its own separate variable as ADA. Then as an optional second argument to listen, we can fire a callback to let us know when the API is ready. And we'll just have a call to log the main URL. 
We can now run the API by going to the terminal and running Node period to run that index.js file. And it should console log it's alive on localhost 8080
 If we paste the URL into the browser, you can see we get a message of cannot get. That's because we don't have any API endpoint set up yet, but Express is still responding with an error message. In fact, you can open up the Network tab in Chrome. If we look closely, we can see that our server responded with a 404 status code, meaning that page was not found. 

At this point. We know our API is working, but debugging it in the browser is usually not the best option. There are many different ways we can access our API. We could use curl from the command line, we can install a VS code extension, or we could use a REST client like insomnia or postman. I'm going to be using insomnia throughout the rest of this video because it provides a really nice way to format your requests and also view a history of all your interactions from insomnia, we can create a new request, then simply paste in our URL.

 We can easily change the HTTP verb from the drop down menu here, click send and then get the response in a nicely formatted a developer friendly way. We can even see the timeline here with our request in yellow and the response in green. But now we need to get back to our JavaScript and add an endpoint to the API. We can do that by chaining an HTTP verb to the app instance. If you type a period after app, you'll get IntelliSense on a bunch of different methods that live on this object. And you'll notice methods for get post patch etc, which represent different HTTP verbs. 

If we want to add a get endpoint to the t shirt URI. We can do that by passing a slash t shirt as its first argument that'll automatically set up our server with that endpoint. Then it's our job to handle a request to it, which we do by passing a callback function as the second argument. Whenever a client or end user requests that URL, it will fire this callback function to handle the request. The function itself provides access to two different objects the request object and the response object. The request is the incoming data. 

While the response is the data we want to send back to the client. The most important thing it does is allow us to send a response back to the client that response can have a status code like 200 for an okay response, then we can send a data payload along with that. If we pass a JavaScript object as the argument then it will send that data back as JSON by default. 

Let's go ahead and save the file then restart the server from the terminal from insomnia. We can then make a GET request to localhost 8080 slash t shirt when we do that we get a JSON object back as the response body with a status code of 200. That's pretty cool. But now let's go back to our code and add a second endpoint. This time a post endpoint followed by a slash in a dynamic URL parameter that represents the ID of that T shirt. There might be millions of different T shirts on this API. 

And a dynamic URL allows us to handle all of them from a single function. When dealing with a post request. It means that the user is trying to create new data on the server or create a new T shirt in this case. First we need the ID which we can get from the URL and its value. is made available to us on the request parameters object. Second, we also need a logo for the t shirt, but the logo is contained in the request body, which if you remember from earlier is a custom data payload contained in the incoming request. In other words, the request object and express allows us to access information from the request message, like the URL parameters, the body, the headers, etc. And now that we have that information, we could use it to save a new record to the database or something along those lines. That's beyond the scope of this video. What we'll do for right now is check to make sure that we have a logo in the request body. And if we don't, then we'll send an error response with a 480 and status code and an error message that we need a logo. 

But assuming we do have a valid logo, we can just send a response with a T shirt that contains that logo and ID. Now let's go back to insomnia. And we'll make a post request to that T shirt endpoint followed by a unique ID that can be whatever you want. Then in the body section, we'll go ahead and add a request body with a format of JSON and it's just a JSON object that contains a logo with a string value. If we send that request, you'll notice we get a 500 error response which means our API code is broken. So what's going on here, it's telling us we have a runtime error, because we can't D structure the property logo from the request body. The reason for that is that express does not parse JSON in the body by default. Not everybody uses express to build a JSON API. 

So that's not the default. behavior. What we need to do here is set up middleware that tells express to parse JSON before the actual data hits the function that we're using here to handle the request. When you hear the term middleware, think of shared code that runs before every endpoint callback that you've defined, very common. Middleware is built into express itself. We can refactor our code here a little bit to make a variable for Express and then we can call app dot use to apply middleware. 

In this case, the middleware we want to apply is the Express dot JSON middleware. Now every request that comes in will first go through this Express JSON middleware, which will convert the body to JSON, therefore making it available in our post callback. Let's go ahead and save, restart our server and then go back to insomnia. And if we send the same exact request, you'll notice this time we get back a successful response. 
In addition, if we make a logo and empty string and try to send the same request, we get a 418 response along with a message that we need a logo.

 Congratulations. You've just built a RESTful API from scratch with no JS and express but before we wrap up the video, there's one more thing you should definitely know about when it comes to restful API's and that is the open API spec, which provides a standard way to describe an API in yaml. It originally came about in something called the swagger framework. And what it allows you to do is describe your API in a way that can be understood by both humans and machines. 

And if you're building a serious API, you get all kinds of awesome benefits in the process, your API will be fully documented, making it much easier for the end user to work with. And because it follows a standard format, you can actually just automatically generate all of your client side or server side code. What I'm using right now is a free tool called Swagger hub, and I can come up here and hit the Export button to automatically generate a bunch of boilerplate code. 

Now, I'm usually not a huge fan of code generators. But there's a more powerful reason to use Open API. When you describe your API with the open API spec. You can then upload the configuration to tools like API gateway on AWS or Google Cloud, where it can be secured, monitored and connected to back end infrastructure. Let me know if you want to see a full tutorial on that topic. But I'm gonna go ahead and wrap things up there. And if you want access to even more advanced content, consider becoming a pro member at fire ship IO. Thanks for watching and I will see you in the next one. Okay, so that's it. do
